<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Linear Bouncing RGB Glitch Timer</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box }
  html, body { width:100%; height:100%; overflow:hidden }
  canvas { display:block; background:#f0f0f0 }
  #startStop {
    position:absolute; bottom:20px; left:50%;
    transform:translateX(-50%);
    padding:10px 20px; font-size:1.2rem;
    border:2px solid #333; border-radius:5%;
    background:#f0f0f0; cursor:pointer; z-index:10;
    transition:background .2s, color .2s;
  }
  #startStop:hover { background:#333; color:#fff }
</style>
</head>
<body>
  <canvas id="c"></canvas>
  <button id="startStop">Start</button>

  <script>
    const canvas = document.getElementById('c');
    const ctx    = canvas.getContext('2d');
    const btn    = document.getElementById('startStop');
    let W, H;
    window.addEventListener('resize', () => {
      W = canvas.width  = window.innerWidth;
      H = canvas.height = window.innerHeight;
    });
    window.dispatchEvent(new Event('resize'));

    // countdown logic
    let duration = 0, remaining = 0, running = false, tick;
    btn.addEventListener('click', () => {
      if (running) {
        clearInterval(tick);
        btn.textContent = 'Start';
      } else if (remaining > 0) {
        tick = setInterval(() => {
          remaining--;
          if (remaining <= 0) {
            clearInterval(tick);
            running = false;
            btn.textContent = 'Start';
          }
        }, 1000);
        btn.textContent = 'Stop';
      }
      running = !running;
    });
    canvas.addEventListener('click', () => {
      if (running) return;
      const v = parseInt(prompt('Enter countdown in seconds:'), 10);
      if (!isNaN(v) && v > 0) remaining = duration = v;
    });

    // movement state
    let x = 100, y = 100;
    let dx = 2, dy = 2;
    const SPEED_UP = 1.1;
    const fontSize = 100;

    // glitch state
    let glitchTime = 0;
    const glitchChance = 0.02, glitchDuration = 5;

    function formatTime(s) {
      const m = String(Math.floor(s / 60)).padStart(2, '0');
      const sec = String(s % 60).padStart(2, '0');
      return `${m}:${sec}`;
    }

    ;(function loop(){
      // draw translucent overlay for rainbow trail
      ctx.fillStyle = 'rgba(240,240,240,0.1)';
      ctx.fillRect(0, 0, W, H);

      const txt = formatTime(remaining);
      ctx.font = `${fontSize}px Inter, sans-serif`;
      ctx.textBaseline = 'top';
      const tw = ctx.measureText(txt).width;
      const th = fontSize;

      // bounce off walls, speed up & change nothing but velocity
      if (x + tw >= W && dx > 0) dx = -dx * SPEED_UP;
      if (x <= 0     && dx < 0) dx = -dx * SPEED_UP;
      if (y + th >= H && dy > 0) dy = -dy * SPEED_UP;
      if (y <= 0     && dy < 0) dy = -dy * SPEED_UP;

      // update position
      x += dx;
      y += dy;

      // pick a continuously cycling hue
      const now = performance.now() / 1000;
      const hue = (now * 60) % 360;

      // glitch trigger
      if (glitchTime > 0) {
        glitchTime--;
      } else if (Math.random() < glitchChance) {
        glitchTime = glitchDuration;
      }

      // draw glitch layers
      if (glitchTime > 0) {
        const off = (Math.random() * 10) - 5;
        ctx.fillStyle = 'rgba(255,0,0,0.7)';
        ctx.fillText(txt, x + off, y);
        ctx.fillStyle = 'rgba(0,0,255,0.7)';
        ctx.fillText(txt, x - off, y);
      }

      // draw main RGB‚Äêcycling text
      ctx.fillStyle = `hsl(${hue},100%,50%)`;
      ctx.fillText(txt, x, y);

      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
