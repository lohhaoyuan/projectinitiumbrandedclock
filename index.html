<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>wahoo with Physics Rotation</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{width:100%;height:100%;overflow:hidden;touch-action:none}
    canvas{display:block;background:#f0f0f0;cursor:pointer}
    /* hide startStop on desktop (pointer: fine) */
    @media (pointer: fine) {
      #startStop { display: none; }
    }
    #startStop{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);padding:10px 20px;font-size:1.2rem;border:2px solid #333;border-radius:5%;background:#f0f0f0;cursor:pointer;z-index:10}
    #startStop:hover{background:#333;color:#fff}
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <button id="startStop">Start</button>
  <script>
    // setup
    const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
    let W, H;
    function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    // timer state
    let duration = 0, remaining = 0;
    let running = false, tick;
    let editing = false, inputBuf = '';
    const btn = document.getElementById('startStop');
    const fontSize = 100;
    let txt = '00:00', tw = 0, th = 0;
    function formatTime(s) {
      const m = String(Math.floor(s/60)).padStart(2,'0'), sec = String(s%60).padStart(2,'0');
      return `${m}:${sec}`;
    }
    function updateTxt() {
      txt = formatTime(remaining);
      ctx.font = `${fontSize}px Inter`;
      tw = ctx.measureText(txt).width;
      th = fontSize;
    }
    updateTxt();

    // controls
    function startTimer() {
      if (remaining <= 0) return;
      running = true;
      btn.textContent = 'Stop';
      tick = setInterval(() => {
        remaining--;
        updateTxt();
        if (remaining <= 0) stopTimer();
      }, 1000);
    }
    function stopTimer() {
      running = false;
      clearInterval(tick);
      btn.textContent = 'Start';
    }
    btn.addEventListener('click', () => {
      if (running) stopTimer();
      else if (remaining > 0) startTimer();
    });

    // keyboard input
    window.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (!editing) {
          if (running) stopTimer(); else startTimer();
        }
        return;
      }
      if (running) return;
      if (e.key >= '0' && e.key <= '9') {
        editing = true;
        inputBuf += e.key;
        applyBuf();
      } else if (e.key === 'Backspace') {
        editing = true;
        inputBuf = inputBuf.slice(0, -1);
        applyBuf();
      } else if (e.key === 'Enter') {
        if (editing && remaining > 0) {
          editing = false;
          startTimer();
        }
      }
    });
    function applyBuf() {
      const v = parseInt(inputBuf || '0', 10);
      const m = Math.floor(v/100), s = v % 100;
      duration = remaining = m*60 + s;
      updateTxt();
    }

    // swipe adjust for touch
    let touchStartX = null, initRem = 0;
    canvas.addEventListener('touchstart', e => {
      if (running) return;
      const t = e.touches[0];
      const mx = t.clientX, my = t.clientY;
      const cx = x + tw/2, cy = y + th/2;
      const cosA = Math.abs(Math.cos(angle)), sinA = Math.abs(Math.sin(angle));
      const hW = (tw * cosA + th * sinA)/2;
      const hH = (tw * sinA + th * cosA)/2;
      if (mx >= cx-hW && mx <= cx+hW && my >= cy-hH && my <= cy+hH) {
        touchStartX = mx; initRem = remaining;
      }
    });
    canvas.addEventListener('touchmove', e => {
      if (touchStartX === null) return;
      e.preventDefault();
      const tx = e.touches[0].clientX;
      remaining = Math.max(0, initRem + Math.floor((tx - touchStartX)/20));
      updateTxt();
    });
    canvas.addEventListener('touchend', () => { touchStartX = null; });

    // click to pause/resume, dblclick to reset
    canvas.addEventListener('click', () => {
      if (editing) return;
      if (running) stopTimer(); else startTimer();
    });
    canvas.addEventListener('dblclick', () => {
      stopTimer();
      remaining = duration;
      updateTxt();
    });

    // physics & animation
    let x = 100, y = 100;
    let dx = 2, dy = 2;
    let angle = 0, av = 0;
    const friction = 0.98;
    const SPEED = 1;
    let glitch = 0, gC = 0.02, gD = 5;
    const trail = [], TD = 2, SAMP = 0.05;
    let last = 0;

    // second label
    const text2 = 'project initium 2.0';
    let x2 = 200, y2 = 200, dx2 = 3, dy2 = 2.5;
    const fs2 = 40;
    let tw2 = 0;
    function update2() { ctx.font = `${fs2}px Inter`; tw2 = ctx.measureText(text2).width; }
    update2();

    function loop() {
      const now = performance.now()/1000;
      // friction + rotation
      av *= friction;
      angle += av;

      // trail sampling
      if (now - last > SAMP) {
        trail.push({ x, y, angle, hue: (now*60)%360, t: now, txt, tw, th });
        last = now;
      }
      while (trail.length && now - trail[0].t > TD) trail.shift();

      // draw
      ctx.clearRect(0,0,W,H);
      ctx.save(); ctx.filter = 'blur(2px)';
      for (const s of trail) {
        ctx.save(); ctx.translate(s.x + s.tw/2, s.y + s.th/2); ctx.rotate(s.angle);
        ctx.font = `${fontSize}px Inter`;
        ctx.fillStyle = `hsla(${s.hue},100%,50%,${1 - (now - s.t)/TD})`;
        ctx.fillText(s.txt, -s.tw/2, -s.th/2);
        ctx.restore();
      }
      ctx.restore();

      // bounce & angular impulse
      const cx = x + tw/2, cy = y + th/2;
      const cA = Math.abs(Math.cos(angle)), sA = Math.abs(Math.sin(angle));
      const hW = (tw*cA + th*sA)/2, hH = (tw*sA + th*cA)/2;
      if ((cx+hW>=W && dx>0) || (cx-hW<=0 && dx<0)) { dx = -dx * SPEED; av += dx * 0.005; }
      if ((cy+hH>=H && dy>0) || (cy-hH<=0 && dy<0)) { dy = -dy * SPEED; av += dy * 0.005; }
      x += dx; y += dy;

      // glitch effect
      if (glitch > 0) glitch--; else if (Math.random() < gC) glitch = gD;

      // draw timer text
      ctx.save(); ctx.translate(cx, cy); ctx.rotate(angle);
      ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowOffsetX = 4; ctx.shadowOffsetY = 4;
      if (glitch > 0) {
        const off = (Math.random()*10)-5;
        ctx.fillStyle = 'rgba(255,0,0,0.7)'; ctx.fillText(txt, -tw/2+off, -th/2);
        ctx.fillStyle = 'rgba(0,0,255,0.7)'; ctx.fillText(txt, -tw/2-off, -th/2);
      }
      ctx.fillStyle = '#000'; ctx.fillText(txt, -tw/2, -th/2);
      if (editing && Math.floor(now*2)%2) ctx.fillRect(tw/2+5, -th/2+10, 5, th-20);
      ctx.restore();

      // bounce & draw second label
      if ((x2+tw2>=W && dx2>0) || (x2<=0 && dx2<0)) dx2 = -dx2;
      if ((y2+th2>=H && dy2>0) || (y2<=0 && dy2<0)) dy2 = -dy2;
      x2 += dx2; y2 += dy2;
      ctx.save(); ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowOffsetX=4; ctx.shadowOffsetY=4;
      ctx.font = `${fs2}px Inter`;
      ctx.fillStyle = '#000';
      ctx.fillText(text2, x2, y2);
      ctx.restore();

      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
