<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Ease-In-Out Bouncing Timer</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box }
  html, body { width:100%; height:100%; overflow:hidden }
  canvas { display:block; background:#f0f0f0 }
  #startStop {
    position:absolute; bottom:20px; left:50%;
    transform:translateX(-50%);
    padding:10px 20px; font-size:1.2rem;
    border:2px solid #333; border-radius:5%;
    background:#f0f0f0; cursor:pointer; z-index:10;
    transition:background .2s, color .2s;
  }
  #startStop:hover { background:#333; color:#fff }
</style>
</head>
<body>
<canvas id="c"></canvas>
<button id="startStop">Start</button>
<script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');
const btn = document.getElementById('startStop');
let W, H;
window.addEventListener('resize', ()=>{ 
  W=c.width=innerWidth; H=c.height=innerHeight; 
});
window.dispatchEvent(new Event('resize'));

// countdown
let duration=0, remaining=0, running=false, tick;
btn.addEventListener('click',()=>{
  if(running){
    clearInterval(tick);
    btn.textContent='Start';
  } else if(remaining>0){
    tick = setInterval(()=>{
      remaining--;
      if(remaining<=0){
        clearInterval(tick);
        running=false;
        btn.textContent='Start';
      }
    },1000);
    btn.textContent='Stop';
  }
  running=!running;
});
c.addEventListener('click',()=>{
  if(running) return;
  const v = parseInt(prompt('Enter seconds:'),10);
  if(!isNaN(v)&&v>0) remaining=duration=v;
});

// ease function
function easeInOut(t){
  return t<0.5
    ? 2*t*t
    : -1 + (4-2*t)*t;
}

// state for tween segment
let x=100, y=100;
let dirX=1, dirY=1;
let baseSpeed=200; // px/sec
const fontSize=100;
let seg = {}; // {startTime, startX, startY, dx, dy, dist, duration}

// compute next segment parameters
function calcSegment(){
  const txt = format(remaining);
  ctx.font = `${fontSize}px Inter, sans-serif`;
  const tw = ctx.measureText(txt).width;
  const th = fontSize;
  
  // unit vector
  const vlen = Math.hypot(dirX, dirY);
  const ux = dirX / vlen, uy = dirY / vlen;

  // how far to each wall?
  const tx = dirX>0 
    ? (W - tw - x)/ux 
    : (0 - x)/ux;
  const ty = dirY>0 
    ? (H - th - y)/uy 
    : (0 - y)/uy;
  // pick the earliest
  const dist = Math.min(tx, ty);
  const duration = dist / baseSpeed;

  seg = {
    startTime: performance.now()/1000,
    startX: x, startY: y,
    dx: ux * dist, 
    dy: uy * dist,
    dist, duration,
    hitX: (tx<ty), // if true, hit vertical wall
  };
}

// format mm:ss
function format(s){
  const m = String(Math.floor(s/60)).padStart(2,'0');
  const sec = String(s%60).padStart(2,'0');
  return `${m}:${sec}`;
}

// kick off first segment
calcSegment();

function draw(){
  const now = performance.now()/1000;
  const t = (now - seg.startTime) / seg.duration;
  const tt = t>1 ? 1 : t;
  const e = easeInOut(tt);

  x = seg.startX + seg.dx*e;
  y = seg.startY + seg.dy*e;

  // if segment done â†’ bounce and start next
  if(t>=1){
    if(seg.hitX) dirX *= -1; else dirY *= -1;
    baseSpeed *= 1.1;            // speed-up
    calcSegment();
  }

  // render
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = `hsl(${(now*60)%360},100%,50%)`;
  ctx.font = `${fontSize}px Inter, sans-serif`;
  ctx.textBaseline = 'top';
  ctx.fillText(format(remaining), x, y);

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
